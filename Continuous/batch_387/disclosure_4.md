# 10142111

## Secure Session-Bound Data Streams with Dynamic Key Derivation

**Concept:** Extend the session verification beyond message authentication to establish secure, dynamically-derived data streams *within* the established session.  Instead of just verifying a message *came* from the session, allow the server and client to negotiate a dedicated, short-lived encryption key derived *from* the session key, for high-bandwidth data transfer independent of the main session channel. This allows for prioritized, secure streams for things like real-time video, audio, or large file transfers without overloading the primary session.

**Specifications:**

**1. Stream Negotiation Phase:**

*   **Client Initiated:** Client sends a `STREAM_REQUEST` message to the server, including:
    *   `stream_id`:  A unique identifier for this new stream (integer).
    *   `bandwidth_request`:  Desired bandwidth for the stream (kbps).
    *   `priority`:  Stream priority level (integer 1-5, 1 being highest).
    *   `data_type`: Description of the data to be transferred (e.g. “video”, “audio”, “file”).
*   **Server Response:** Server responds with a `STREAM_ACCEPT` or `STREAM_REJECT` message.
    *   `STREAM_ACCEPT` includes:
        *   `stream_id`:  Echoed from the client.
        *   `agreed_bandwidth`: The bandwidth allocated to the stream (may be lower than requested).
        *   `derived_key`: A 256-bit AES key derived using a Key Derivation Function (KDF) such as HKDF. The KDF input consists of:
            *   The established session key.
            *   `stream_id`.
            *   A salt value (randomly generated by the server, and included in the `STREAM_ACCEPT` message).
*   **KDF Specification:** `HKDF(session_key, salt, stream_id, SHA256)`

**2. Data Transfer Phase:**

*   All data transmitted on the newly negotiated stream is encrypted using AES-256 in CBC mode with a randomly generated Initialization Vector (IV) prepended to each data block.
*   The IV is unique for each block to prevent replay attacks.
*   Data blocks are segmented into manageable sizes (e.g., 4KB).

**3. Stream Termination Phase:**

*   Client or Server can terminate a stream by sending a `STREAM_TERMINATE` message with the `stream_id`.
*   Upon stream termination, the derived key is immediately discarded.

**4. Security Considerations:**

*   **Key Rotation:**  A mechanism for periodically re-deriving and rotating the stream keys to mitigate long-term key compromise.  This could be triggered after a certain amount of data has been transferred, or at fixed intervals.
*   **Traffic Shaping:** Server must enforce bandwidth limits to prevent a single stream from monopolizing resources.
*   **Denial of Service (DoS) Protection:** Implement rate limiting on `STREAM_REQUEST` messages to prevent DoS attacks.
*   **Stream ID Spoofing:** The `stream_id` must be treated as sensitive information to prevent attackers from intercepting and replaying data on existing streams.



**Pseudocode (Server-Side – Stream Negotiation):**

```
function handle_stream_request(client_connection, stream_request_data):
    stream_id = stream_request_data.stream_id
    bandwidth_request = stream_request_data.bandwidth_request
    priority = stream_request_data.priority

    // Check resource availability & bandwidth limits

    agreed_bandwidth = min(bandwidth_request, max_bandwidth_per_stream)

    salt = generate_random_salt()

    session_key = get_session_key_for_connection(client_connection)

    derived_key = HKDF(session_key, salt, stream_id, SHA256)

    stream_accept_data = {
        "stream_id": stream_id,
        "agreed_bandwidth": agreed_bandwidth,
        "derived_key": derived_key,
        "salt": salt
    }

    send_message(client_connection, "STREAM_ACCEPT", stream_accept_data)
```